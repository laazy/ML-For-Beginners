# בניית מודל רגרסיה באמצעות Scikit-learn: ארבע דרכים לרגרסיה

## הערת מתחילים

רגרסיה ליניארית משמשת כאשר אנו רוצים לחזות **ערך מספרי** (לדוגמה, מחיר בית, טמפרטורה או מכירות).  
היא פועלת על ידי מציאת קו ישר שמייצג בצורה הטובה ביותר את הקשר בין תכונות הקלט לפלט.

במהלך השיעור הזה, נתמקד בהבנת המושג לפני שנחקור טכניקות רגרסיה מתקדמות יותר.  
![אינפוגרפיקה של רגרסיה ליניארית לעומת פולינומית](../../../../translated_images/he/linear-polynomial.5523c7cb6576ccab.webp)  
> אינפוגרפיקה מאת [דאסני מדיפלי](https://twitter.com/dasani_decoded)  
## [מבחן לפני ההרצאה](https://ff-quizzes.netlify.app/en/ml/)

> ### [השיעור זמין גם ב-R!](../../../../2-Regression/3-Linear/solution/R/lesson_3.html)  
### מבוא

עד כה חקרתם מהי רגרסיה עם דוגמת נתונים שנאספה ממאגר מחירי הדלעות שבו נשתמש לאורך כל השיעור. בנוסף, חזיתם זאת באמצעות Matplotlib.

כעת אתם מוכנים לצלול לעומק יותר לרגרסיה עבור למידת מכונה. בעוד שויזואליזציה מאפשרת להבין את הנתונים, הכוח האמיתי של למידת מכונה מגיע מ-_אימון מודלים_. מודלים מאומנים על נתונים היסטוריים כדי ללכוד באופן אוטומטי את התלויות בנתונים, והם מאפשרים לכם לחזות תוצאות עבור נתונים חדשים שהמודל לא ראה בעבר.

בשיעור הזה תלמדו יותר על שני סוגי רגרסיה: _רגרסיה ליניארית בסיסית_ ו_רגרסיה פולינומית_, יחד עם חלק מהמתמטיקה שמאחורי הטכניקות האלה. מודלים אלו יאפשרו לנו לחזות מחירי דלעות בהתאם לנתוני קלט שונים.

[![למידת מכונה למתחילים - הבנת רגרסיה ליניארית](https://img.youtube.com/vi/CRxFT8oTDMg/0.jpg)](https://youtu.be/CRxFT8oTDMg "למידת מכונה למתחילים - הבנת רגרסיה ליניארית")

> 🎥 הקליקו על התמונה למעלה לסרטון קצר על רגרסיה ליניארית.

> לאורך כל תכנית הלימודים, אנו מניחים ידע מתמטי מינימלי, ושואפים להפוך זאת לנגיש לסטודנטים הבאים מתחומים אחרים, לכן שימו לב להערות, 🧮 קריאות, דיאגרמות וכלי למידה נוספים המסייעים בהבנה.

### דרישות קדם

כעת אתם אמורים להכיר את מבנה נתוני הדלעות שאנו בודקים. תוכלו למצוא אותם טעונים ומנוקים מראש בקובץ _notebook.ipynb_ של השיעור. בקובץ, מחיר הדלעות מוצג לפרוטה חדשה במסגרת נתונים. ודאו שאתם יכולים להריץ את היומנים הללו ב-Kernels ב-Visual Studio Code.

### הכנה

כאות זיכרון, אתם טוענים את הנתונים האלה כדי לשאול עליהם שאלות.

- מתי הזמן הטוב ביותר לקנות דלעות?  
- איזה מחיר ניתן לצפות לקופסת דלעות מיניאטוריות?  
- האם כדאי לקנות אותן בסלים של חצי בחמישה ליטרים או בקופסת 1 1/9 בחמישה ליטרים?  
בואו נמשיך לחקור את הנתונים האלה.

בשיעור הקודם, יצרתם מסגרת נתונים של Pandas וטענתם חלק מהמערכת הנתונים המקורית, תוך סטנדרטיזציה של המחירים לפי החמישה ליטרים. אך בכך הצלחתם לאסוף כ-400 נקודות נתונים בלבד ורק עבור חודשים סתוויים.

הסתכלו על הנתונים שהטענו מראש ביומן הנלווה לשיעור הזה. הנתונים נטענים מראש וגרף פיזור ראשוני מצויר למען הצגת נתוני החודש. ייתכן שנוכל לקבל מידע מפורט יותר על טבעם של הנתונים באמצעות ניקוי נוסף.

## קו רגרסיה ליניארי

כפי שלמדתם בשיעור 1, המטרה של תרגיל רגרסיה ליניארית היא להיות מסוגלים לשרטט קו כדי:

- **להראות קשרים בין משתנים**. להראות את הקשר בין משתנים  
- **לבצע תחזיות**. לבצע תחזיות מדויקות לגבי מיקום נקודת נתונים חדשה ביחס לקו.

שיטה טיפוסית של **רגרסיית שאריות מינימליות** היא ציור קו כזה. המונח "שאריות מינימליות" מתייחס לתהליך הפחתת השגיאה הכוללת במודל שלנו. עבור כל נקודת נתונים, אנו מודדים את המרחק האנכי (שנקרא שארית) בין הנקודה האמיתית והקו שלנו.

אנו מרבעים מרחקים אלה משתי סיבות עיקריות:  

1. **מגמות גודל על פני כיוון:** אנו רוצים להתייחס לטעויות של -5 ו+5 באותה צורה. הריבוע הופך את כל הערכים לחיוביים.  

2. **עונש לחריגים:** החישוב בריבוע נותן משקל רב יותר לטעויות גדולות ומאלץ את הקו להישאר קרוב לנקודות רחוקות.

לאחר מכן, אנו מוסיפים את כל הערכים המרובעים יחד. המטרה שלנו היא למצוא את הקו הספציפי שבו סכום זה הוא הכי נמוך (הערך הקטן ביותר האפשרי) — ומכאן השם "שאריות מינימליות".

> **🧮 הראו לי את המתמטיקה**  
>  
> הקו הזה, הנקרא _קו התאמה אופטימלי_, ניתן לביטוי באמצעות [משוואה](https://en.wikipedia.org/wiki/Simple_linear_regression):  
>  
> ```
> Y = a + bX
> ```
>  
> `X` הוא 'המשתנה המסביר'. `Y` הוא 'המשתנה התלוי'. השיפוע של הקו הוא `b` ו-`a` הוא נקודת החיתוך עם ציר ה-Y, שמתייחס לערך של `Y` כאשר `X = 0`.  
>  
>![חישוב השיפוע](../../../../translated_images/he/slope.f3c9d5910ddbfcf9.webp)  
>  
> ראשית, חשב את השיפוע `b`. אינפוגרפיקה מאת [ג'ן לופר](https://twitter.com/jenlooper)  
>  
> במילים אחרות, ובהתייחס לשאלה המקורית על מחירי דלעות: "לחזות את מחיר הדלעות לכל חמישה ליטרים לפי חודש", `X` מתייחס למחיר ו-`Y` לחודש המכירה.  
>  
>![השלמת המשוואה](../../../../translated_images/he/calculation.a209813050a1ddb1.webp)  
>  
> חשב את ערך Y. אם אתה משלם כ-4$, זה חייב להיות אפריל! אינפוגרפיקה מאת [ג'ן לופר](https://twitter.com/jenlooper)  
>  
> המתמטיקה שמחשבת את הקו חייבת להציג את שיפוע הקו, התלוי גם בנקודת החיתוך, או היכן ש-`Y` נמצא כש-`X = 0`.  
>  
> ניתן לצפות בשיטת החישוב לערכים אלו באתר [Math is Fun](https://www.mathsisfun.com/data/least-squares-regression.html). כמו כן, בקרו ב-[מחשבון שאריות מינימליות](https://www.mathsisfun.com/data/least-squares-calculator.html) כדי לצפות כיצד ערכי המספרים משפיעים על הקו.

## קורלציה

מונח נוסף להבין הוא **מקדם הקורלציה** בין משתני X ו-Y הניתנים. בעזרת גרף פיזור תוכלו במהירות להמחיש ויזואלית את המקדם הזה. גרף עם נקודות מפוזרות בקו מסודר יציג קורלציה גבוהה, ואילו גרף עם נקודות מפוזרות בכל מקום בין X ו-Y יציג קורלציה נמוכה.

מודל רגרסיה ליניארית טוב יהיה כזה שיש לו מקדם קורלציה גבוה (קרוב ל-1 יותר מאשר 0) בשימוש בשיטת רגרסיית שאריות מינימליות עם קו רגרסיה.

✅ הריצו את היומן הנלווה לשיעור הזה והסתכלו על גרף הפיזור של חודש מול מחיר. האם הנתונים המקשרים בין חודש למחיר במכירות הדלעות נראים עם קורלציה גבוהה או נמוכה, לפי הפרשנות הויזואלית שלכם של גרף הפיזור? האם זה משתנה אם תשתמשו במדידה מדויקת יותר במקום `חודש`, למשל *יום בשנה* (כלומר מספר הימים מתחילת השנה)?

בקוד למטה, נניח שניקינו את הנתונים, וקיבלנו מסגרת נתונים בשם `new_pumpkins`, כפי הבא:

ID | Month | DayOfYear | Variety | City | Package | Low Price | High Price | Price  
---|-------|-----------|---------|------|---------|-----------|------------|-------  
70 | 9 | 267 | PIE TYPE | BALTIMORE | 1 1/9 bushel cartons | 15.0 | 15.0 | 13.636364  
71 | 9 | 267 | PIE TYPE | BALTIMORE | 1 1/9 bushel cartons | 18.0 | 18.0 | 16.363636  
72 | 10 | 274 | PIE TYPE | BALTIMORE | 1 1/9 bushel cartons | 18.0 | 18.0 | 16.363636  
73 | 10 | 274 | PIE TYPE | BALTIMORE | 1 1/9 bushel cartons | 17.0 | 17.0 | 15.454545  
74 | 10 | 281 | PIE TYPE | BALTIMORE | 1 1/9 bushel cartons | 15.0 | 15.0 | 13.636364

> הקוד לניקוי הנתונים זמין ב-[`notebook.ipynb`](notebook.ipynb). ביצענו את אותם שלבי ניקוי כמו בשיעור הקודם, וחישבנו את עמודת `DayOfYear` באמצעות הביטוי הבא:

```python
day_of_year = pd.to_datetime(pumpkins['Date']).apply(lambda dt: (dt-datetime(dt.year,1,1)).days)
```
  
כעת כשברשותכם הבנה של המתמטיקה שמאחורי הרגרסיה הליניארית, ניצור מודל רגרסיה כדי לבדוק אם נוכל לחזות איזו חבילה של דלעות תהיה עם המחירים הטובים ביותר. מישהו שקונה דלעות לטובת חלקת דלעות לחג עשוי לרצות מידע זה על מנת לאפיין את רכישות חבילות הדלעות שלו.

## חיפוש קורלציה

[![למידת מכונה למתחילים - חיפוש קורלציה: המפתח לרגרסיה ליניארית](https://img.youtube.com/vi/uoRq-lW2eQo/0.jpg)](https://youtu.be/uoRq-lW2eQo "למידת מכונה למתחילים - חיפוש קורלציה: המפתח לרגרסיה ליניארית")

> 🎥 הקליקו על התמונה למעלה לסרטון קצר על קורלציה.

בשיעור הקודם כנראה שראיתם שמחיר ממוצע לאורך חודשים שונים נראה כך:

<img alt="מחיר ממוצע לפי חודש" src="../../../../translated_images/he/barchart.a833ea9194346d76.webp" width="50%"/>

זה מצביע על כך שלפחות יש קורלציה כלשהי, ונוכל לנסות לאמן מודל רגרסיה ליניארית כדי לחזות את הקשר בין `חודש` ו-`מחיר`, או בין `DayOfYear` ל-`מחיר`. להלן גרף הפיזור שמציג את הקשר האחרון:

<img alt="גרף פיזור של מחיר מול יום בשנה" src="../../../../translated_images/he/scatter-dayofyear.bc171c189c9fd553.webp" width="50%" />

בואו נראה אם יש קורלציה באמצעות פונקציית `corr`:

```python
print(new_pumpkins['Month'].corr(new_pumpkins['Price']))
print(new_pumpkins['DayOfYear'].corr(new_pumpkins['Price']))
```
  
נראה שהקורלציה די קטנה, -0.15 לפי `חודש` ו- -0.17 לפי `DayOfMonth`, אך יש עדיין קשר אחר שחשוב לקחת בחשבון. נראה שיש אשכולות שונים של מחירים המתאימים לסוגי דלעות שונים. כדי לאשר השערה זו, נצייר כל קטגוריית דלעות בצבע שונה. באמצעות העברת פרמטר `ax` לפונקציית הפיזור נוכל לצייר את כל הנקודות באותו גרף:

```python
ax=None
colors = ['red','blue','green','yellow']
for i,var in enumerate(new_pumpkins['Variety'].unique()):
    df = new_pumpkins[new_pumpkins['Variety']==var]
    ax = df.plot.scatter('DayOfYear','Price',ax=ax,c=colors[i],label=var)
```
  
<img alt="גרף פיזור של מחיר מול יום בשנה בצבעים" src="../../../../translated_images/he/scatter-dayofyear-color.65790faefbb9d54f.webp" width="50%" />  

החקירה שלנו מצביעה על כך שלסוג הדלעות יש השפעה גדולה יותר על המחיר הכולל מאשר התאריך בפועל של המכירה. ניתן לראות זאת באמצעות גרף עמודות:

```python
new_pumpkins.groupby('Variety')['Price'].mean().plot(kind='bar')
```
  
<img alt="גרף עמודות של המחיר לפי סוג דלעת" src="../../../../translated_images/he/price-by-variety.744a2f9925d9bcb4.webp" width="50%" />  

נתרכז לרגע בסוג דלעת אחד בלבד, 'pie type', ונבדוק מה ההשפעה של התאריך על המחיר:

```python
pie_pumpkins = new_pumpkins[new_pumpkins['Variety']=='PIE TYPE']
pie_pumpkins.plot.scatter('DayOfYear','Price') 
```
<img alt="גרף פיזור של מחיר מול יום בשנה לפי סוג pie" src="../../../../translated_images/he/pie-pumpkins-scatter.d14f9804a53f927e.webp" width="50%" />  

אם נכנס לחשב את הקורלציה בין `מחיר` ו-`DayOfYear` באמצעות הפונקציה `corr`, נקבל משהו כמו `-0.27` – כלומר אימון מודל חיזוי הגיוני.

> לפני אימון מודל רגרסיה ליניארית, חשוב לוודא שהנתונים שלנו נקיים. רגרסיה ליניארית לא עובדת טוב עם ערכים חסרים, לכן הגיוני להיפטר מכל התאים הריקים:

```python
pie_pumpkins.dropna(inplace=True)
pie_pumpkins.info()
```
  
גישה נוספת תהיה למלא את אותם ערכים ריקים בערכי ממוצע מהעמודה המתאימה.

## רגרסיה ליניארית פשוטה

[![למידת מכונה למתחילים - רגרסיה ליניארית ופולינומית באמצעות Scikit-learn](https://img.youtube.com/vi/e4c_UP2fSjg/0.jpg)](https://youtu.be/e4c_UP2fSjg "למידת מכונה למתחילים - רגרסיה ליניארית ופולינומית באמצעות Scikit-learn")

> 🎥 הקליקו על התמונה למעלה לסרטון קצר על רגרסיה ליניארית ופולינומית.

כדי לאמן את מודל הרגרסיה הליניארית שלנו, נשתמש בספריית **Scikit-learn**.

```python
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split
```
  
נתחיל בהפרדת ערכי הקלט (תכונות) ופלט המצופה (תג) למערכי numpy נפרדים:

```python
X = pie_pumpkins['DayOfYear'].to_numpy().reshape(-1,1)
y = pie_pumpkins['Price']
```
  
> שימו לב שנדרשנו לבצע `reshape` על נתוני הקלט כדי שחבילת הרגרסיה הליניארית תוכל להבין אותם נכון. רגרסיה ליניארית מצפה למערך דו-ממדי כקלט, שבו כל שורה במערך מתאימה לוקטור של תכונות קלט. במקרה שלנו, מאחר שיש לנו קלט אחד בלבד - אנו צריכים מערך בצורת N&times;1, כאשר N הוא גודל מערכת הנתונים.

לאחר מכן, עלינו לחלק את הנתונים למערכי אימון ובדיקה, כדי שנוכל לאמת את המודל לאחר האימון:

```python
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
```
  
לבסוף, אימון מודל הרגרסיה הליניארית עצמו לוקח רק שתי שורות קוד. אנו מגדירים את העצם `LinearRegression`, ומתאימים אותו לנתונים שלנו באמצעות המתודה `fit`:

```python
lin_reg = LinearRegression()
lin_reg.fit(X_train,y_train)
```

האובייקט `LinearRegression` לאחר ביצוע `fit` מכיל את כל מקדמי הרגרסיה, שאליהם ניתן לגשת באמצעות המאפיין `.coef_`. במקרה שלנו, יש רק מקדם אחד, שצריך להיות בסביבות `-0.017`. זה אומר שהמחירים נראים כיורדים במקצת עם הזמן, אבל לא יותר מדי, בסביבות 2 סנטים ליום. ניתן גם לגשת לנקודת החיתוך של הרגרסיה עם ציר ה-Y באמצעות `lin_reg.intercept_` - היא תהיה בסביבות `21` במקרה שלנו, מה שמצביע על המחיר בתחילת השנה.

כדי לראות עד כמה המודל שלנו מדויק, נוכל לחזות מחירים על קבוצת נתוני מבחן, ואז למדוד עד כמה התחזיות שלנו קרובות לערכים הצפויים. ניתן לעשות זאת באמצעות מדד השגיאה הממוצעת הריבועית (MSE), שהוא הממוצע של כל ההבדלים הריבועים בין הערך הצפוי והערך החזוי.

```python
pred = lin_reg.predict(X_test)

mse = np.sqrt(mean_squared_error(y_test,pred))
print(f'Mean error: {mse:3.3} ({mse/np.mean(pred)*100:3.3}%)')
```

השגיאה שלנו נראית בסביבות 2 נקודות, שזה כ־17%. לא כל כך טוב. מדד נוסף לאיכות המודל הוא **מקדם הקביעה**, שניתן לקבל כך:

```python
score = lin_reg.score(X_train,y_train)
print('Model determination: ', score)
```
אם הערך הוא 0, זה אומר שהמודל אינו מתחשב בנתוני הקלט, ופועל כ*התחזית הקווית הגרועה ביותר*, שהיא פשוט ערך ממוצע של התוצאה. ערך של 1 אומר שניתן לחזות באופן מושלם את כל התוצאות הצפויות. במקרה שלנו, המקדם הוא בסביבות 0.06, שזה יחסית נמוך.

אנו יכולים גם לגרור את נתוני המבחן יחד עם קו הרגרסיה כדי לראות טוב יותר איך הרגרסיה פועלת במקרה שלנו:

```python
plt.scatter(X_test,y_test)
plt.plot(X_test,pred)
```

<img alt="Linear regression" src="../../../../translated_images/he/linear-results.f7c3552c85b0ed1c.webp" width="50%" />

## רגרסיה פולינומיאלית

סוג נוסף של רגרסיה לינארית הוא רגרסיה פולינומיאלית. בעוד שלפעמים יש קשר לינארי בין משתנים - ככל שהדלעת גדולה יותר בנפח, כך המחיר גבוה יותר - לפעמים יחסים אלו אינם ניתנים לייצוג במישור או בקו ישר.

✅ הנה [כמה דוגמאות נוספות](https://online.stat.psu.edu/stat501/lesson/9/9.8) לנתונים שיכולים להשתמש ברגרסיה פולינומיאלית

הסתכל שוב על הקשר בין התאריך למחיר. האם נקודות הפיזור האלה נראות כמו שצריך להיות מנותחות בקו ישר? האם המחירים לא יכולים להשתנות? במקרה הזה, אפשר לנסות רגרסיה פולינומיאלית.

✅ פולינומים הם ביטויים מתמטיים שעשויים לכלול משתנה אחד או יותר ומקדמים

רגרסיה פולינומיאלית יוצרת קו מעוקל, כדי להתאים טוב יותר לנתונים שאינם לינאריים. במקרה שלנו, אם נכלול משתנה `DayOfYear` בריבוע בנתוני הקלט, נוכל להתאים את הנתונים שלנו בעקומת פרבולה, שתהיה לה מינימום בנקודה מסוימת בתוך השנה.

ספריית Scikit-learn כוללת [API צנרת](https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.make_pipeline.html?highlight=pipeline#sklearn.pipeline.make_pipeline) נוח לשילוב שלבי עיבוד נתונים שונים יחד. **צנרת** היא שרשרת של **אומדנים**. במקרה שלנו, ניצור צנרת שמוסיפה תחילה תכונות פולינומיאליות למודל, ואז מאמנת את הרגרסיה:

```python
from sklearn.preprocessing import PolynomialFeatures
from sklearn.pipeline import make_pipeline

pipeline = make_pipeline(PolynomialFeatures(2), LinearRegression())

pipeline.fit(X_train,y_train)
```

שימוש ב־`PolynomialFeatures(2)` אומר שנכלול את כל הפולינומים מדרגה שנייה מתוך נתוני הקלט. במקרה שלנו זה פשוט יהיה `DayOfYear`<sup>2</sup>, אבל אם יש לנו שני משתני קלט X ו־Y, זה יוסיף X<sup>2</sup>, XY ו־Y<sup>2</sup>. ניתן גם להשתמש בפולינומים מדרגות גבוהות יותר אם רוצים.

ניתן להשתמש בצנרות באותו אופן כמו האובייקט `LinearRegression` המקורי, כלומר, נוכל לבצע `fit` לצנרת, ואז להשתמש ב־`predict` כדי לקבל את תוצאות התחזית. להלן הגרף המציג את נתוני המבחן, ועקומת ההתאמה:

<img alt="Polynomial regression" src="../../../../translated_images/he/poly-results.ee587348f0f1f60b.webp" width="50%" />

בשימוש ברגרסיה פולינומיאלית, אנחנו יכולים לקבל MSE נמוך יותר במעט ומקדם קביעה גבוה יותר, אבל לא באופן משמעותי. נצטרך לקחת בחשבון תכונות נוספות!

> ניתן לראות שמחירי הדלעות הנמוכים ביותר נצפים בסביבות ליל כל הקדושים. איך אפשר להסביר זאת?

🎃 כל הכבוד, יצרת מודל שיכול לסייע לחזות את מחיר דלעת לפאי. כנראה שתוכל לחזור על אותו תהליך לכל סוגי הדלעות, אבל זה יהיה מעייף. בוא נלמד עכשיו איך לקחת בחשבון מגוון דלעת במודל שלנו!

## תכונות קטגוריות

בעולם האידיאלי, אנחנו רוצים להיות מסוגלים לחזות מחירים לסוגים שונים של דלעות באמצעות אותו מודל. עם זאת, עמודת `Variety` שונה במקצת מעמודות כמו `Month`, כי היא מכילה ערכים לא מספריים. עמודות כאלה נקראות **קטגוריות**.

[![ML למתחילים - תחזיות תכונות קטגוריות עם רגרסיה לינארית](https://img.youtube.com/vi/DYGliioIAE0/0.jpg)](https://youtu.be/DYGliioIAE0 "ML למתחילים - תחזיות תכונות קטגוריות עם רגרסיה לינארית")

> 🎥 לחצו על התמונה למעלה לסרטון קצר שמסביר שימוש בתכונות קטגוריות.

כאן ניתן לראות כיצד המחיר הממוצע תלוי בסוג:

<img alt="Average price by variety" src="../../../../translated_images/he/price-by-variety.744a2f9925d9bcb4.webp" width="50%" />

כדי לקחת בחשבון את הסוג, צריכים תחילה להמיר אותו לצורה מספרית, או **לקודד** אותו. קיימות כמה דרכים לעשות זאת:

* **קידוד מספרי** פשוט יבנה טבלה של סוגים שונים, ואז יחליף את שם הסוג במספר אינדקס בטבלה הזו. זו לא רעיון טוב לרגרסיה לינארית, כי היא מתחשבת בערך המספרי האמיתי של האינדקס, ומוסיפה אותו לתוצאה אחרי הכפל במקדם כלשהו. במקרה שלנו, הקשר בין מספר האינדקס למחיר אינו לינארי, אפילו אם נסדר את האינדקסים בסדר מסוים.
* **קידוד One-hot** יחליף את עמודת `Variety` בארבע עמודות שונות, אחת לכל סוג. כל עמודה תכיל `1` אם השורה המתאימה היא של אותו סוג, ו־`0` אחרת. משמעות הדבר היא שיהיו ארבעה מקדמים ברגרסיה הלינארית, אחד לכל סוג דלעת, האחראיים ל"מחיר ההתחלתי" (או במדויק יותר "התווסף למחיר") עבור אותו סוג.

הקוד שלמטה מראה כיצד ניתן לקודד one-hot את הסוג:

```python
pd.get_dummies(new_pumpkins['Variety'])
```

 ID | FAIRYTALE | MINIATURE | MIXED HEIRLOOM VARIETIES | PIE TYPE
----|-----------|-----------|--------------------------|----------
70 | 0 | 0 | 0 | 1
71 | 0 | 0 | 0 | 1
... | ... | ... | ... | ...
1738 | 0 | 1 | 0 | 0
1739 | 0 | 1 | 0 | 0
1740 | 0 | 1 | 0 | 0
1741 | 0 | 1 | 0 | 0
1742 | 0 | 1 | 0 | 0

כדי לאמן רגרסיה לינארית תוך שימוש בסוג המקודד one-hot כקלט, צריך פשוט לאתחל את הנתונים `X` ו־`y` כראוי:

```python
X = pd.get_dummies(new_pumpkins['Variety'])
y = new_pumpkins['Price']
```

שאר הקוד זהה למה שהשתמשנו בו למעלה להכשרת רגרסיה לינארית. אם תנסו זאת, תראו שהשגיאה הממוצעת הריבועית (MSE) תהיה בערך זהה, אבל נקבל מקדם קביעה הרבה יותר גבוה (~77%). כדי לקבל תחזיות מדויקות יותר, נוכל לקחת בחשבון עוד תכונות קטגוריות, כמו גם תכונות מספריות, כמו `Month` או `DayOfYear`. כדי לקבל מערך תכונות גדול אחד, נוכל להשתמש ב־`join`:

```python
X = pd.get_dummies(new_pumpkins['Variety']) \
        .join(new_pumpkins['Month']) \
        .join(pd.get_dummies(new_pumpkins['City'])) \
        .join(pd.get_dummies(new_pumpkins['Package']))
y = new_pumpkins['Price']
```

כאן אנחנו גם מתחשבים ב־`City` ובסוג `Package`, מה שמקנה לנו MSE של 2.84 (10%), ומקדם קביעה של 0.94!

## לשלב הכל יחד

כדי ליצור את המודל הטוב ביותר, נוכל להשתמש בנתונים משולבים (קטגוריים מקודדים one-hot + מספריים) מהדוגמה למעלה יחד עם רגרסיה פולינומיאלית. להלן הקוד המלא לנוחיותכם:

```python
# להגדיר נתוני אימון
X = pd.get_dummies(new_pumpkins['Variety']) \
        .join(new_pumpkins['Month']) \
        .join(pd.get_dummies(new_pumpkins['City'])) \
        .join(pd.get_dummies(new_pumpkins['Package']))
y = new_pumpkins['Price']

# לבצע פיצול לאימון ובדיקה
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)

# להגדיר ולאמן את צנרת הנתונים
pipeline = make_pipeline(PolynomialFeatures(2), LinearRegression())
pipeline.fit(X_train,y_train)

# לחזות תוצאות עבור נתוני הבדיקה
pred = pipeline.predict(X_test)

# לחשב שגיאת ממוצע ריבועי (MSE) ו-\u05D4\u05D7\u05D5\u05DE\u05D3\u05D4
mse = np.sqrt(mean_squared_error(y_test,pred))
print(f'Mean error: {mse:3.3} ({mse/np.mean(pred)*100:3.3}%)')

score = pipeline.score(X_train,y_train)
print('Model determination: ', score)
```

זה אמור לתת לנו את מקדם הקביעה הטוב ביותר של כמעט 97%, ו־MSE=2.23 (שגיאת תחזית של כ־8%).

| מודל | MSE | מקדם קביעה |
|-------|-----|---------------|
| `DayOfYear` לינארי | 2.77 (17.2%) | 0.07 |
| `DayOfYear` פולינומיאלית | 2.73 (17.0%) | 0.08 |
| `Variety` לינארי | 5.24 (19.7%) | 0.77 |
| כל התכונות לינארי | 2.84 (10.5%) | 0.94 |
| כל התכונות פולינומיאלית | 2.23 (8.25%) | 0.97 |

🏆 כל הכבוד! יצרת ארבעה מודלים של רגרסיה בשיעור אחד, ושיפרת את איכות המודל ל־97%. בחלק הסופי בנושא רגרסיה תלמד על רגרסיה לוגיסטית לקביעת קטגוריות.

---
## 🚀אתגר

בדוק כמה משתנים שונים במחברת זו כדי לראות כיצד מתאם מתייחס לדיוק המודל.

## [מבחן לאחר ההרצאה](https://ff-quizzes.netlify.app/en/ml/)

## סקירה ולמידה עצמית

בשיעור זה למדנו על רגרסיה לינארית. יש סוגים חשובים נוספים של רגרסיה. קרא על שיטות Stepwise, Ridge, Lasso ו-Elasticnet. קורס טוב ללמידה נוספת הוא [קורס הלמידה הסטטיסטית של סטנפורד](https://online.stanford.edu/courses/sohs-ystatslearning-statistical-learning)

## משימה

[בנה מודל](assignment.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**כתב ויתור**:  
מסמך זה תורגם באמצעות שירות תרגום מבוסס בינה מלאכותית [Co-op Translator](https://github.com/Azure/co-op-translator). למרות שאנו שואפים לדייק, יש להיות מודעים לכך שתרגומים אוטומטיים עלולים להכיל שגיאות או אי דיוקים. יש לראות את המסמך המקורי בשפת המקור כמקור המוסמך והמהימן. למידע קריטי מומלץ להשתמש בתרגום מקצועי שנעשה על ידי אדם. אנו לא נושא באחריות לכל אי הבנה או פרשנות שגויה הנובעים משימוש בתרגום זה.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->